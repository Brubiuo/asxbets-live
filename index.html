<script>
    // ðŸ’¥ API BASE URL ðŸ’¥
    const API_BASE = "https://asxbetslive.mjung4.workers.dev";
    
    // ===== tiny fetch helper with timeouts/retries =====
    // Increased default timeout from 4500ms to 6000ms
    async function fetchJson(url, { timeoutMs = 6000, retries = 2, backoff = 600 } = {}) {
      for (let a = 0; a <= retries; a++) {
        const ctl = new AbortController();
        const to = setTimeout(() => ctl.abort(), timeoutMs + a * 300);
        try {
          const r = await fetch(url, { headers: { Accept: "application/json" }, cache: "no-store", signal: ctl.signal });
          clearTimeout(to);
          if (!r.ok) throw new Error("HTTP " + r.status);
          return await r.json();
        } catch (e) {
          clearTimeout(to);
          if (a === retries) return null;
          await new Promise(res => setTimeout(res, backoff * (a + 1)));
        }
      }
      return null;
    }

    // ===== UI bits =====
    const statusElÂ  = document.getElementById("status");
    const liveDotÂ  Â = document.getElementById("liveDot");
    const mainPaneÂ  = document.getElementById("main-pane");
    const postsElÂ  Â = document.getElementById("posts");
    const errElÂ  Â  Â = document.getElementById("err");
    const tmplÂ  Â  Â  = document.getElementById("comment-card");
    const postTmplÂ  = document.getElementById("post-mini");
    const pauseBtnÂ  = document.getElementById("pauseBtn");

    function showErr(msg) {
      errEl.style.display = 'block';
      errEl.textContent = msg;
    }
    function clearErr() { errEl.style.display = 'none'; errEl.textContent = ""; }

    // ===== ticker detection =====
    // Initial set for ASX context (common ASX stocks)
    let TICKER_ALLOW = new Set(["BHP","CBA","WBC","ANZ","NAB","CSL","RIO","FMG","APT"]);
    (async () => {
      // This will attempt to fetch a new list of tickers from the API
      try { const j = await fetchJson(API_BASE + "/tickers", { timeoutMs: 3000, retries: 0 }); if (j?.tickers?.length) TICKER_ALLOW = new Set(j.tickers.map(s=>String(s).toUpperCase())); } catch {}
    })();
    const DYNAMIC_ALLOW = new Set();
    const TICKER_RE = /\$?[A-Z]{1,5}(?:[.-][A-Z]{1,2})?/g;
    const acceptSymbol = (sym, hadDollar) => (sym.length <= 2 ? hadDollar : (hadDollar || TICKER_ALLOW.has(sym) || DYNAMIC_ALLOW.has(sym)));
    function extractUniqueTickers(text){ if(!text) return []; const set=new Set(); for(const m of (text.match(TICKER_RE)||[])){ const hadDollar=m.startsWith("$"); const sym=m.replace(/^\$/,'').toUpperCase(); if (acceptSymbol(sym,hadDollar)) set.add(sym); } return [...set]; }
    function highlightTickers(s){ if(!s) return ""; return s.replace(TICKER_RE, m=>{ const hadDollar=m.startsWith("$"); const sym=m.replace(/^\$/,'').toUpperCase(); if(acceptSymbol(sym,hadDollar)){ return `<span class="ticker-token" data-see="${sym}" title="See ${sym} comments"><span class="ticker-label">${sym}</span><svg class="ticker-arrow" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M7 5l5 5-5 5"/></svg></span>`;} return m; }); }
    const formatUser = (a) => String(a || "unknown").replace(/^u\//i, "");
    function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"}[s])); }
    function stripHtmlToText(html){ const el=document.createElement("div"); el.innerHTML=html||""; return el.textContent||el.innerText||""; }
    function timeAgo(ms){ const s=Math.max(1,Math.floor((Date.now()-ms)/1000)); if(s<60)return s+"s ago"; const m=Math.floor(s/60); if(m<60)return m+"m ago"; const h=Math.floor(m/60); if(h<24)return h+"h ago"; const d=Math.floor(h/24); return d+"d ago"; }

    // ===== Top tickers state (All other ticker logic remains the same) =====
    const TOP_TICKERS_N = 15;
    const WINDOW_MS = 60*60*1000;
    const mentionQueue = []; const counts = new Map(); const countedComments = new Set(); const commentsByTicker = new Map();
    let hiddenTickers = new Set(JSON.parse(localStorage.getItem("wsb_hidden_tickers") || "[]"));
    const saveHidden = ()=> localStorage.setItem("wsb_hidden_tickers", JSON.stringify([...hiddenTickers]));

    function addCommentMentions(commentId, plainText){
      if (!plainText || countedComments.has(commentId)) return;
      const syms = extractUniqueTickers(plainText);
      if (!syms.length) { countedComments.add(commentId); return; }
      const now = Date.now();
      syms.forEach(sym => { mentionQueue.push({ sym, t: now, commentId }); counts.set(sym, (counts.get(sym) || 0) + 1); DYNAMIC_ALLOW.add(sym); });
      countedComments.add(commentId);
      pruneAndRenderTop();
    }
    function indexCommentMentionsForSyms(meta, syms){
      if (!Array.isArray(syms) || !syms.length) return;
      const t = meta?.created_utc ? meta.created_utc*1000 : Date.now();
      const base = { id: meta?.id || meta?.name || meta?.permalink || Math.random().toString(36).slice(2), t, author: meta?.author || "unknown", score: meta?.score ?? 0, body_html: meta?.body_html, body: meta?.body, permalink: meta?.permalink || "#", postTitle: meta?.post?.title || meta?.postTitle || "" };
      syms.forEach(S0 => { const S = String(S0).toUpperCase(); const arr = commentsByTicker.get(S) || []; if (!arr.some(x => x.id === base.id)) { arr.unshift({...base}); arr.sort((a,b)=> b.t - a.t); if (arr.length > 400) arr.length = 400; commentsByTicker.set(S, arr);} if (openModalSym === S) renderModal(S); });
    }
    function indexCommentMentions(meta, plain){ if(!plain) return; const syms = extractUniqueTickers(plain); if(!syms.length) return; indexCommentMentionsForSyms(meta, syms); }

    function addSeedEntries(entries){
      if (!Array.isArray(entries)) return;

      for (const e of entries){
        if (!e || !e.sym || typeof e.t !== "number") continue;

        const S = String(e.sym).toUpperCase();
        const cid = e.commentId || `${S}-${e.t}`; // stable id for dedupe
        const tms = e.t;

        const alreadyCounted = countedComments.has(cid);

        DYNAMIC_ALLOW.add(S);

        if (!alreadyCounted) {
          mentionQueue.push({ sym: S, t: tms, commentId: cid });
          counts.set(S, (counts.get(S) || 0) + 1);
          countedComments.add(cid);
        }

        const providedText = (e.body || e.snippet || "").trim();
        const fallbackText = providedText || "(preloaded mention; full body not available yet)";
        const meta = {
          id: cid,
          author: e.author || "u/unknown",
          score: e.score ?? 0,
          created_utc: Math.floor(tms / 1000),
          body: fallbackText,
          body_html: "",
          permalink: e.permalink || "#",
          post: { title: e.postTitle || "", permalink: e.postPermalink || e.permalink || "#" },
          postTitle: e.postTitle || ""
        };
        indexCommentMentionsForSyms(meta, [S]);
      }

      pruneAndRenderTop();
    }

    function pruneAndRenderTop(){
      const list = document.getElementById("top-tickers");
      const resetBtn = document.getElementById("reset-hidden");
      const cutoff = Date.now() - WINDOW_MS;
      while (mentionQueue.length && mentionQueue[0].t < cutoff){
        const old = mentionQueue.shift();
        const cur = (counts.get(old.sym) || 0) - 1;
        if (cur <= 0) counts.delete(old.sym); else counts.set(old.sym, cur);
      }
      list.innerHTML = "";
      const top = Array.from(counts.entries()).filter(([sym]) => !hiddenTickers.has(sym)).sort((a,b)=>b[1]-a[1]).slice(0, TOP_TICKERS_N);
      if (!top.length) {
        const li = document.createElement("li"); li.className = "text-zinc-500"; li.textContent = "listeningâ€¦"; list.appendChild(li);
      } else {
        top.forEach(([sym, cnt]) => {
          const li = document.createElement("li");
          li.className = "flex items-center justify-between gap-2";
          li.innerHTML = `<span class="truncate"><span class="ticker-label">${sym}</span> <span class="text-zinc-400">â€” ${cnt}</span></span><div class="flex items-center gap-2 flex-shrink-0"><button class="see-btn" data-see="${sym}" type="button">See comments</button><button class="hide-btn" data-hide="${sym}" type="button">hide</button></div>`;
          list.appendChild(li);
        });
        list.classList.add("flash"); setTimeout(()=> list.classList.remove("flash"), 420);
      }
      resetBtn.classList.toggle("hidden", hiddenTickers.size === 0);
    }
    // modal
    const modalEl = document.getElementById("commentsModal");
    const modalTitle = document.getElementById("modalTitle");
    const modalSubtitle = document.getElementById("modalSubtitle");
    const modalList = document.getElementById("modalList");
    let openModalSym = null;
    const inflightByTicker = new Set();
    function getRecentComments(sym){
      const arr = commentsByTicker.get(sym) || [];
      const cutoff = Date.now() - WINDOW_MS;
      const fresh = arr.filter(x => x.t >= cutoff);
      if (fresh.length !== arr.length) commentsByTicker.set(sym, fresh);
      return fresh;
    }
    async function backfillTicker(sym){
      if (inflightByTicker.has(sym)) return; inflightByTicker.add(sym);
      try{
        const data = await fetchJson(`${API_BASE}/by_ticker?sym=${encodeURIComponent(sym)}&minutes=60&ts=${Date.now()}`, { timeoutMs: 6000, retries: 2 });
        const list = Array.isArray(data) ? data : (data?.items || []);
        for (const item of list){
          const c = item.comment || item;
          const p = item.post || { title: item.postTitle, permalink: item.postPermalink || item.permalink };
          indexCommentMentionsForSyms({ ...c, post: p }, [sym]);
        }
      } catch {} finally {
        inflightByTicker.delete(sym);
        if (openModalSym === sym) renderModal(sym);
      }
    }
    function openModal(sym){ openModalSym = sym; renderModal(sym); if (getRecentComments(sym).length === 0) backfillTicker(sym); modalEl.classList.remove("hidden"); document.body.style.overflow = "hidden"; }
    function closeModal(){ openModalSym = null; modalEl.classList.add("hidden"); document.body.style.overflow = ""; modalList.innerHTML = ""; }
    function renderModal(sym){
      const items = getRecentComments(sym);
      modalTitle.innerHTML = `<span class="ticker-label">${sym}</span> comments`;
      modalSubtitle.textContent = `${items.length} mention${items.length===1?"":"s"} in the last hour`;
      modalList.innerHTML = "";
      if (!items.length){
        const empty = document.createElement("div");
        empty.className = "text-sm text-zinc-400";
        empty.textContent = "Fetching comments for this tickerâ€¦";
        modalList.appendChild(empty);
        return;
      }
      for (const c of items){
        const card = document.createElement("article");
        card.className = "frame p-3 md:p-4";
        const when = timeAgo(c.t);
        const plain = (c.body_html ? stripHtmlToText(c.body_html) : (c.body || "")).trim();
        const hi = highlightTickers(escapeHtml(plain || "(preloaded mention; full body not available yet)"));
        card.innerHTML = `
          <header class="flex items-center justify-between text-xs text-zinc-300 mb-2">
            <div class="flex items-center gap-2 flex-wrap">
              <span class="chip">u:${escapeHtml(formatUser(c.author))}</span>
              <span class="chip">score ${c.score ?? 0}</span>
              <span class="chip">${when}</span>
            </div>
            <a href="${c.permalink}" target="_blank" rel="noopener" class="underline decoration-dotted">Open on Reddit â†—</a>
          </header>
          ${c.postTitle ? `<h4 class="font-semibold text-sm mb-2">${escapeHtml(c.postTitle)}</h4>` : ``}
          <div class="text-sm body-html"><p>${hi}</p></div>
        `;
        modalList.appendChild(card);
      }
    }

    document.addEventListener("click", (e) => {
      try {
        const hideBtn = e.target.closest(".hide-btn");
        if (hideBtn && hideBtn.hasAttribute("data-hide")) { hiddenTickers.add(hideBtn.getAttribute("data-hide")); saveHidden(); pruneAndRenderTop(); return; }
        if (e.target && e.target.id === "reset-hidden") { hiddenTickers.clear(); saveHidden(); pruneAndRenderTop(); return; }
        const seeBtn = e.target.closest(".see-btn, .ticker-token");
        if (seeBtn && seeBtn.hasAttribute("data-see")) { openModal(seeBtn.getAttribute("data-see")); return; }
        if (e.target && (e.target.id === "modalClose" || e.target.hasAttribute("data-close-modal"))) { closeModal(); return; }
      } catch {}
    });

    // ===== live 5s poller (strict forward) =====
    let _lastShownMs = 0;
    let paused = false;
    let tickTimer = null;
    let healthTimer = null;
    let consecutiveFailures = 0;
    let _lastRendered = null;

    function setPaused(p){
      paused = p;
      pauseBtn.textContent = paused ? "Unpause" : "Pause";
      liveDot.classList.toggle("paused", paused);
      statusEl.textContent = paused ? "paused" : "live";
      if (paused) stopTimers(); else startTimers();
    }
    pauseBtn.addEventListener("click", () => setPaused(!paused));

    function startTimers(){
      stopTimers();
      tickTimer = setInterval(pollOnce, 5000);
      healthTimer = setInterval(healthCheck, 15000);
      pollOnce();
      healthCheck();
    }
    function stopTimers(){
      if (tickTimer) clearInterval(tickTimer);
      if (healthTimer) clearInterval(healthTimer);
      tickTimer = null; healthTimer = null;
    }

    async function healthCheck(){
      const h = await fetchJson(API_BASE + "/health", { timeoutMs: 2500, retries: 0 });
      if (!h?.ok) {
        statusEl.textContent = "reconnectingâ€¦";
      } else if (!paused) {
        statusEl.textContent = "live";
      }
    }

    async function pollOnce(){
      if (paused) return;

      // Increased timeout from 2200ms to 5000ms and retries from 0 to 1
      const res = await fetchJson(`${API_BASE}/recent_comments?minutes=3&ts=${Date.now()}`, { timeoutMs: 5000, retries: 1 });
      if (!res) {
        consecutiveFailures++;
        statusEl.textContent = "reconnectingâ€¦";
        if (consecutiveFailures >= 3) showErr("Network hiccup contacting API. Retryingâ€¦");
        if (_lastRendered) renderMain(_lastRendered);
        return;
      }
      clearErr();
      consecutiveFailures = 0;

      const list = Array.isArray(res) ? res : (res.items || []);
      if (!Array.isArray(list) || list.length === 0) {
        if (_lastRendered) renderMain(_lastRendered);
        statusEl.textContent="live";
        return;
      }

      const chosen = list[0];
      const c = chosen.comment || chosen;
      const ts = Math.min(((c?.created_utc||0)*1000) || Date.now(), Date.now());

      if (ts > _lastShownMs) {
        const post = chosen.post || { title: chosen.postTitle, permalink: chosen.postPermalink || chosen.permalink };
        const parents = chosen.parents || [];
        const payload = { comment: c, parents, post };
        renderMain(payload);
        _lastRendered = payload;
        return;
      }

      if (_lastRendered) {
        renderMain(_lastRendered);
      } else {
        const post = chosen.post || { title: chosen.postTitle, permalink: chosen.postPermalink || chosen.permalink };
        const parents = chosen.parents || [];
        const payload = { comment: c, parents, post };
        renderMain(payload);
        _lastRendered = payload;
      }
    }

    function renderMain({ comment, parents, post }){
      const node = tmpl.content.firstElementChild.cloneNode(true);
      q(node,"[data-author]").textContent = formatUser(comment.author);
      q(node,"[data-score]").textContent = comment.score ?? 0;
      q(node,"[data-time]").textContentÂ  = timeAgo(comment.created_utc*1000);
      q(node,"[data-post-link]").textContent = post?.title || "(post)";
      q(node,"[data-post-link]").href = post?.permalink || "#";
      q(node,"[data-comment-link]").href = comment.permalink;

      const thread = q(node, "[data-thread]");
      (parents||[]).forEach(p => {
        const txt = p.body_html ? escapeHtml(stripHtmlToText(p.body_html)) : escapeHtml(p.body || "");
        thread.appendChild(blockHtml(p, txt, false));
      });
      const cText = comment.body_html ? escapeHtml(stripHtmlToText(comment.body_html)) : escapeHtml(comment.body || "");
      thread.appendChild(blockHtml(comment, cText, true));

      const ts = Math.min((comment.created_utc||0)*1000, Date.now());
      if (ts > _lastShownMs) _lastShownMs = ts;

      const commentId = comment.id || comment.name || comment.permalink;
      const plain = stripHtmlToText(comment.body_html||"") || comment.body || "";
      addCommentMentions(commentId, plain);
      indexCommentMentions({...comment, post}, plain);

      mainPane.innerHTML = "";
      mainPane.appendChild(node);
      statusEl.textContent = "live";
    }
    function q(node, sel){ return node.querySelector(sel); }
    function blockHtml(meta, innerHtml, isCurrent=false){
      const inner = highlightTickers(innerHtml);
      const wrap = document.createElement("div");
      wrap.className = isCurrent ? "current-block gain-border" : "parent-block";
      if (isCurrent) wrap.classList.add("flash");
      wrap.innerHTML = `<div class="text-xs text-zinc-300 mb-2">u:${escapeHtml(formatUser(meta.author))} â€¢ ${timeAgo(meta.created_utc * 1000)} â€¢ score ${meta.score ?? 0}</div><div class="text-sm body-html">${inner}</div>`;
      return wrap;
    }
    // ===== preload top tickers (1h) on boot, with retries =====
    async function preheatTopTickers(minutes=60){
      for (let attempt = 1; attempt <= 6; attempt++) {
        const [r1, r2] = await Promise.allSettled([
          fetchJson(`${API_BASE}/recent_comments?minutes=${minutes}&ts=${Date.now()}`, { timeoutMs: 9000, retries: 1 }),
          fetchJson(`${API_BASE}/seed?minutes=${minutes}&ts=${Date.now()}`, { timeoutMs: 9000, retries: 1 }),
        ]);

        let any = false;
        if (r1.status === "fulfilled" && r1.value) {
          const arr = Array.isArray(r1.value) ? r1.value : (r1.value.items || []);
          for (const it of arr) {
            const c = it.comment || it;
            const p = it.post || { title: it.postTitle, permalink: it.postPermalink || it.permalink };
            const plain = c.body || (c.body_html ? stripHtmlToText(c.body_html) : "");
            indexCommentMentions({ ...c, post: p }, plain);
            addCommentMentions(c.id || c.name || c.permalink || Math.random().toString(36).slice(2), plain);
            any = true;
          }
        }

        if (r2.status === "fulfilled" && r2.value) {
          const entries = Array.isArray(r2.value?.entries) ? r2.value.entries : (Array.isArray(r2.value) ? r2.value : []);
          if (entries.length) { addSeedEntries(entries); any = true; }
        }

        if (any) { pruneAndRenderTop(); return; }
        await new Promise(res => setTimeout(res, Math.min(2000 * attempt, 12000)));
      }
      showErr("Top tickers preload had no data yet. It will fill as new comments arrive.");
    }

    // ===== posts rail =====
    let _lastPosts = [];

    async function loadPosts(){
      const p = await fetchJson(API_BASE + "/posts", { timeoutMs: 4500, retries: 1 });
      const list = (p && Array.isArray(p.posts)) ? p.posts : [];

      if (!list.length) return;

      if (_lastPosts.length && list[0]?.id === _lastPosts[0]?.id) return;

      postsEl.innerHTML = "";
      for (const post of list) {
        const node = postTmpl.content.firstElementChild.cloneNode(true);
        const q = (n,s) => n.querySelector(s);
        q(node,"[data-post-link]").textContent = post.title;
        q(node,"[data-post-link]").href = post.permalink;
        q(node,"[data-author]").textContent = post.author;
        q(node,"[data-time]").textContent = timeAgo(post.created_utc * 1000);
        q(node,"[data-score]").textContent = post.score ?? 0;
        q(node,"[data-comments]").textContent = post.comments ?? 0;
        postsEl.appendChild(node);
      }

      _lastPosts = list;
    }

    // ===== boot =====
    (async function boot(){
      const h = await fetchJson(API_BASE + "/health", { timeoutMs: 2500, retries: 0 });
      if (!h?.ok) showErr("Backend health check failed. If this persists, your Worker may not be deployed.");

      startTimers();
      preheatTopTickers();
      loadPosts();
      setInterval(loadPosts, 60000);
    })();
</script>
