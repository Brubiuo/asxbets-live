<!doctype html>
<html lang="en">
<head>
Â  <meta charset="utf-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1" />
Â  <title>ASX Bets Live</title>
Â  <script src="https://cdn.tailwindcss.com"></script>
Â  <style>
Â  Â  :root { --bg: 18 18 22; --gain:#00ff7a; --gain-glow:0 0 12px rgba(0,255,122,.45); --gold:#ffb23d; }
Â  Â  body {
Â  Â  Â  background:
Â  Â  Â  Â  radial-gradient(1200px 600px at 20% -10%, rgba(0,255,140,0.08), transparent 40%),
Â  Â  Â  Â  radial-gradient(1000px 500px at 120% 10%, rgba(0,180,255,0.07), transparent 40%),
Â  Â  Â  Â  rgb(var(--bg));
Â  Â  }
Â  Â  .glass { background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.08); }
Â  Â  .neon { text-shadow: 0 0 12px rgba(0,255,140,.5); }
Â  Â  .chip { border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); border-radius: 9999px; padding: 2px 10px; font-size: 12px; }
Â  Â  .frame { border: 1px solid rgba(255,255,255,.12); border-radius: 16px; }
Â  Â  .gain-border { border-color: var(--gain)!important; box-shadow: 0 0 0 1px var(--gain), var(--gain-glow); }
Â  Â  .flash { animation: flashGain .6s ease-out; }
Â  Â  @keyframes flashGain { 0%{box-shadow:0 0 0 0 rgba(0,255,122,0)} 35%{box-shadow:0 0 0 3px rgba(0,255,122,.55),0 0 18px rgba(0,255,122,.55)} 100%{box-shadow:0 0 0 0 rgba(0,255,122,0)} }
Â  Â  a { color:#7de3ff } a:hover{ text-decoration: underline }
Â  Â  .fade-in{ animation: fade .25s ease-out } @keyframes fade{ from{opacity:0;transform:translateY(6px)} to{opacity:1;transform:translateY(0)} }
Â  Â  .body-html p{ margin-bottom:.5rem }
Â  Â  #err{ display:none }
Â  Â  .btn-pause{ border:1px solid rgba(0,255,122,.7); background:rgba(0,255,122,.12); color:#dbffe9; border-radius:9999px; padding:6px 12px; font-size:12px; font-weight:700; letter-spacing:.3px }
Â  Â  .live-wrap{ display:flex; align-items:center; gap:.5rem }
Â  Â  .live-dot{ width:10px; height:10px; border-radius:9999px; background:#ff3b30; box-shadow:0 0 10px rgba(255,59,48,.9); animation:blink 1s infinite }
Â  Â  .live-dot.paused{ background:#ffd60a; box-shadow:0 0 10px rgba(255,214,10,.9); animation:blinkPause 1.2s infinite }
Â  Â  @keyframes blink{ 0%,60%{opacity:1} 60.1%,100%{opacity:.25} }
Â  Â  @keyframes blinkPause{ 0%,60%{opacity:1} 60.1%,100%{opacity:.45} }
Â  Â  .btn-tip{ border-radius:9999px; padding:6px 12px; font-size:12px; font-weight:700; background:linear-gradient(180deg,#ffd86b,#ffb23d); color:#222; border:1px solid rgba(255,178,61,.8); box-shadow: 0 2px 18px rgba(255,178,61,.35); text-decoration:none }
Â  Â  .btn-tip:hover{ filter:brightness(1.05); text-decoration:none }
Â  Â  .thread-guide{ border-left:2px solid rgba(255,255,255,.16) }
Â  Â  .parent-block{ background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:12px }
Â  Â  .current-block{ background:rgba(255,255,255,.03); border-radius:12px; padding:12px; }
Â  Â  .ticker-token{ display:inline-flex; align-items:center; gap:0; padding:.05rem 0 .05rem .20rem; border-radius:.5rem; cursor:pointer; user-select:none; transition: background .15s ease, box-shadow .15s ease; }
Â  Â  .ticker-token:hover{ background: rgba(255,255,255,.06); box-shadow: inset 0 0 0 1px rgba(255,255,255,.08); }
Â  Â  .ticker-label{ color:var(--gold); font-weight:800 }
Â  Â  .ticker-arrow{ width:12px; height:12px; opacity:.75; transform: translateY(-.5px); }
Â  Â  .hide-btn{ font-size: 11px; text-transform: lowercase; color: rgba(255,255,255,.55); margin-left: .5rem; border: 1px solid rgba(255,255,255,.14); border-radius: 9999px; padding: 2px 6px; background: rgba(255,255,255,.06); }
Â  Â  .hide-btn:hover{ color:#fff; border-color: rgba(255,255,255,.35); }
Â  Â  .see-btn{ font-size: 11px; text-transform: lowercase; color:#c9ffee; border:1px solid rgba(0,255,122,.55); border-radius:9999px; padding:2px 8px; background: rgba(0,255,122,.10); box-shadow: 0 0 10px rgba(0,255,122,.15) inset; }
Â  Â  .see-btn:hover{ filter:brightness(1.08); }
Â  Â  .pop { animation: pop .18s ease-out }
Â  Â  @keyframes pop { from{ transform:scale(.98); opacity:.0 } to{ transform:scale(1); opacity:1 } }
Â  </style>
</head>
<body class="text-zinc-100">
Â  <div class="max-w-7xl mx-auto p-4 lg:p-8">
Â  Â  <header class="flex items-center justify-between mb-4">
Â  Â  Â  <div>
Â  Â  Â  Â  <div class="live-wrap">
Â  Â  Â  Â  Â  <span id="liveDot" class="live-dot" aria-hidden="true"></span>
Â  Â  Â  Â  Â  <h1 class="text-2xl md:text-3xl font-black tracking-tight neon">ASX Bets Live</h1>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <p class="text-sm text-zinc-400 mt-1">A real-time feed of r/asx_bets comments across all posts.</p>
Â  Â  Â  </div>
Â  Â  Â  <div class="flex items-center gap-2">
Â  Â  Â  Â  <span class="chip" id="status">connectingâ€¦</span>
Â  Â  Â  Â  <a href="https://www.reddit.com/r/asx_bets/" target="_blank" class="chip">r/asxbets â†—</a>
Â  Â  Â  Â  <a href="https://buymeacoffee.com/brubiu" target="_blank" rel="noopener" class="btn-tip inline-flex items-center justify-center flex-shrink-0 px-3 py-2 text-xs sm:text-[12px] leading-none whitespace-nowrap" title="Send a tip">
Â  Â  Â  Â  Â  <span class="sm:hidden">Tip me pls</span><span class="hidden sm:inline">Send a tip to keep the lights on</span>
Â  Â  Â  Â  </a>
Â  Â  Â  </div>
Â  Â  </header>
Â  Â  <div id="err" class="mb-4 p-3 rounded-lg border border-red-400/50 text-red-200 bg-red-950/30"></div>
Â  Â  <div class="grid grid-cols-1 lg:grid-cols-7 gap-6">
Â  Â  Â  <main class="glass rounded-2xl p-4 md:p-6 col-span-1 lg:col-span-5 min-h-[65vh]">
Â  Â  Â  Â  <div class="flex items-center gap-3 mb-3 flex-wrap">
Â  Â  Â  Â  Â  <button id="pauseBtn" class="btn-pause" type="button">Pause</button>
Â  Â  Â  Â  Â  <span class="text-xs text-zinc-400"><strong>Live updates</strong></span>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="main-pane" class="space-y-4"></div>
Â  Â  Â  </main>
Â  Â  Â  <aside class="col-span-1 lg:col-span-2">
Â  Â  Â  Â  <div class="glass rounded-2xl p-4 mb-4">
Â  Â  Â  Â  Â  <div class="flex items-center justify-between mb-3">
Â  Â  Â  Â  Â  Â  <h2 class="text-sm uppercase tracking-wider text-zinc-400">Top Tickers (ASX Focus)</h2>
Â  Â  Â  Â  Â  Â  <button id="reset-hidden" class="text-[11px] text-zinc-400 hover:text-zinc-200 underline decoration-dotted hidden" type="button">reset hidden</button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <ol id="top-tickers" class="space-y-1 text-[13px]"><li class="text-zinc-500">loadingâ€¦</li></ol>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="glass rounded-2xl p-4 max-h=[65vh] overflow-y-auto">
Â  Â  Â  Â  Â  <h2 class="text-sm uppercase tracking-wider text-zinc-400 mb-3">Recent Posts</h2>
Â  Â  Â  Â  Â  <div id="posts" class="space-y-3"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  </aside>
Â  Â  </div>
Â  </div>
Â  <footer class="mt-8 border-t border-zinc-800/60">
Â  Â  <div class="max-w-7xl mx-auto px-4 lg:px-8 py-6">
Â  Â  Â  <p class="text-[11px] uppercase tracking-[0.2em] text-zinc-500/70 text-left">NONE OF THIS IS FINANCIAL ADVICE, IDIOTS.</p>
Â  Â  Â  </div>
Â  </footer>
Â  <template id="comment-card">
Â  Â  <article class="frame fade-in">
Â  Â  Â  <div class="p-4 md:p-5">
Â  Â  Â  Â  <header class="mb-3">
Â  Â  Â  Â  Â  <div class="flex items-center gap-2 text-xs text-zinc-300">
Â  Â  Â  Â  Â  Â  <span class="chip">u:<span data-author></span></span>
Â  Â  Â  Â  Â  Â  <span class="chip">score <span data-score></span></span>
Â  Â  Â  Â  Â  Â  <span class="chip"><span data-time></span></span>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <h3 class="mt-3 font-semibold text-lg"><a data-post-link href="#" target="_blank"></a></h3>
Â  Â  Â  Â  </header>
Â  Â  Â  Â  <section class="space-y-3">
Â  Â  Â  Â  Â  <div class="pl-4 thread-guide space-y-3" data-thread></div>
Â  Â  Â  Â  </section>
Â  Â  Â  Â  <footer class="mt-4 text-sm"><a data-comment-link href="#" target="_blank" class="underline decoration-dotted">Open comment â†—</a></footer>
Â  Â  Â  </div>
Â  Â  </article>
Â  </template>
Â  <template id="post-mini">
Â  Â  <article class="frame p-3 hover:gain-border transition">
Â  Â  Â  <a data-post-link href="#" target="_blank" class="block font-semibold"></a>
Â  Â  Â  <div class="text-xs text-zinc-400 mt-1">
Â  Â  Â  Â  by <span data-author></span> â€¢ <span data-time></span> â€¢ <span data-score></span> â–² â€¢ <span data-comments></span> comments
Â  Â  Â  </div>
Â  Â  </article>
Â  </template>
Â  <div id="commentsModal" class="hidden fixed inset-0 z-50">
Â  Â  <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" data-close-modal></div>
Â  Â  <div class="absolute inset-x-0 top-10 sm:top-16 mx-auto max-w-2xl px-4">
Â  Â  Â  <div class="glass rounded-2xl shadow-xl pop">
Â  Â  Â  Â  <header class="flex items-center justify-between p-4 border-b border-white/10">
Â  Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  Â  <h3 id="modalTitle" class="text-lg font-bold tracking-tight"></h3>
Â  Â  Â  Â  Â  Â  <p id="modalSubtitle" class="text-xs text-zinc-400"></p>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <button id="modalClose" class="chip text-[11px]" type="button">Esc to close</button>
Â  Â  Â  Â  </header>
Â  Â  Â  Â  <div class="p-4"><div id="modalList" class="max-h-[70vh] overflow-y-auto space-y-3 pr-1"></div></div>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>
Â  <script>
Â  Â  // ðŸ’¥ API BASE URL ðŸ’¥
Â  Â  const API_BASE = "https://asxbetslive.mjung4.workers.dev";
Â  Â Â 
Â  Â  // ===== tiny fetch helper with timeouts/retries =====
Â  Â  async function fetchJson(url, { timeoutMs = 4500, retries = 2, backoff = 600 } = {}) {
Â  Â  Â  for (let a = 0; a <= retries; a++) {
Â  Â  Â  Â  const ctl = new AbortController();
Â  Â  Â  Â  const to = setTimeout(() => ctl.abort(), timeoutMs + a * 300);
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  const r = await fetch(url, { headers: { Accept: "application/json" }, cache: "no-store", signal: ctl.signal });
Â  Â  Â  Â  Â  clearTimeout(to);
Â  Â  Â  Â  Â  if (!r.ok) throw new Error("HTTP " + r.status);
Â  Â  Â  Â  Â  return await r.json();
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  clearTimeout(to);
Â  Â  Â  Â  Â  if (a === retries) return null;
Â  Â  Â  Â  Â  await new Promise(res => setTimeout(res, backoff * (a + 1)));
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return null;
Â  Â  }

Â  Â  // ===== UI bits =====
Â  Â  const statusElÂ  = document.getElementById("status");
Â  Â  const liveDotÂ  Â = document.getElementById("liveDot");
Â  Â  const mainPaneÂ  = document.getElementById("main-pane");
Â  Â  const postsElÂ  Â = document.getElementById("posts");
Â  Â  const errElÂ  Â  Â = document.getElementById("err");
Â  Â  const tmplÂ  Â  Â  = document.getElementById("comment-card");
Â  Â  const postTmplÂ  = document.getElementById("post-mini");
Â  Â  const pauseBtnÂ  = document.getElementById("pauseBtn");

Â  Â  function showErr(msg) {
Â  Â  Â  errEl.style.display = 'block';
Â  Â  Â  errEl.textContent = msg;
Â  Â  }
Â  Â  function clearErr() { errEl.style.display = 'none'; errEl.textContent = ""; }

Â  Â  // ===== ticker detection =====
Â  Â  // Initial set for ASX context (common ASX stocks)
Â  Â  let TICKER_ALLOW = new Set(["BHP","CBA","WBC","ANZ","NAB","CSL","RIO","FMG","APT"]);
Â  Â  (async () => {
Â  Â  Â  // This will attempt to fetch a new list of tickers from the API
Â  Â  Â  try { const j = await fetchJson(API_BASE + "/tickers", { timeoutMs: 3000, retries: 0 }); if (j?.tickers?.length) TICKER_ALLOW = new Set(j.tickers.map(s=>String(s).toUpperCase())); } catch {}
Â  Â  })();
Â  Â  const DYNAMIC_ALLOW = new Set();
Â  Â  const TICKER_RE = /\$?[A-Z]{1,5}(?:[.-][A-Z]{1,2})?/g;
Â  Â  const acceptSymbol = (sym, hadDollar) => (sym.length <= 2 ? hadDollar : (hadDollar || TICKER_ALLOW.has(sym) || DYNAMIC_ALLOW.has(sym)));
Â  Â  function extractUniqueTickers(text){ if(!text) return []; const set=new Set(); for(const m of (text.match(TICKER_RE)||[])){ const hadDollar=m.startsWith("$"); const sym=m.replace(/^\$/,'').toUpperCase(); if (acceptSymbol(sym,hadDollar)) set.add(sym); } return [...set]; }
Â  Â  function highlightTickers(s){ if(!s) return ""; return s.replace(TICKER_RE, m=>{ const hadDollar=m.startsWith("$"); const sym=m.replace(/^\$/,'').toUpperCase(); if(acceptSymbol(sym,hadDollar)){ return `<span class="ticker-token" data-see="${sym}" title="See ${sym} comments"><span class="ticker-label">${sym}</span><svg class="ticker-arrow" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M7 5l5 5-5 5"/></svg></span>`;} return m; }); }
Â  Â  const formatUser = (a) => String(a || "unknown").replace(/^u\//i, "");
Â  Â  function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"}[s])); }
Â  Â  function stripHtmlToText(html){ const el=document.createElement("div"); el.innerHTML=html||""; return el.textContent||el.innerText||""; }
Â  Â  function timeAgo(ms){ const s=Math.max(1,Math.floor((Date.now()-ms)/1000)); if(s<60)return s+"s ago"; const m=Math.floor(s/60); if(m<60)return m+"m ago"; const h=Math.floor(m/60); if(h<24)return h+"h ago"; const d=Math.floor(h/24); return d+"d ago"; }

Â  Â  // ===== Top tickers state (All other ticker logic remains the same) =====
Â  Â  const TOP_TICKERS_N = 15;
Â  Â  const WINDOW_MS = 60*60*1000;
Â  Â  const mentionQueue = []; const counts = new Map(); const countedComments = new Set(); const commentsByTicker = new Map();
Â  Â  let hiddenTickers = new Set(JSON.parse(localStorage.getItem("wsb_hidden_tickers") || "[]"));
Â  Â  const saveHidden = ()=> localStorage.setItem("wsb_hidden_tickers", JSON.stringify([...hiddenTickers]));

Â  Â  function addCommentMentions(commentId, plainText){
Â  Â  Â  if (!plainText || countedComments.has(commentId)) return;
Â  Â  Â  const syms = extractUniqueTickers(plainText);
Â  Â  Â  if (!syms.length) { countedComments.add(commentId); return; }
Â  Â  Â  const now = Date.now();
Â  Â  Â  syms.forEach(sym => { mentionQueue.push({ sym, t: now, commentId }); counts.set(sym, (counts.get(sym) || 0) + 1); DYNAMIC_ALLOW.add(sym); });
Â  Â  Â  countedComments.add(commentId);
Â  Â  Â  pruneAndRenderTop();
Â  Â  }
Â  Â  function indexCommentMentionsForSyms(meta, syms){
Â  Â  Â  if (!Array.isArray(syms) || !syms.length) return;
Â  Â  Â  const t = meta?.created_utc ? meta.created_utc*1000 : Date.now();
Â  Â  Â  const base = { id: meta?.id || meta?.name || meta?.permalink || Math.random().toString(36).slice(2), t, author: meta?.author || "unknown", score: meta?.score ?? 0, body_html: meta?.body_html, body: meta?.body, permalink: meta?.permalink || "#", postTitle: meta?.post?.title || meta?.postTitle || "" };
Â  Â  Â  syms.forEach(S0 => { const S = String(S0).toUpperCase(); const arr = commentsByTicker.get(S) || []; if (!arr.some(x => x.id === base.id)) { arr.unshift({...base}); arr.sort((a,b)=> b.t - a.t); if (arr.length > 400) arr.length = 400; commentsByTicker.set(S, arr);} if (openModalSym === S) renderModal(S); });
Â  Â  }
Â  Â  function indexCommentMentions(meta, plain){ if(!plain) return; const syms = extractUniqueTickers(plain); if(!syms.length) return; indexCommentMentionsForSyms(meta, syms); }

Â  Â  function addSeedEntries(entries){
Â  Â  Â  if (!Array.isArray(entries)) return;

Â  Â  Â  for (const e of entries){
Â  Â  Â  Â  if (!e || !e.sym || typeof e.t !== "number") continue;

Â  Â  Â  Â  const S = String(e.sym).toUpperCase();
Â  Â  Â  Â  const cid = e.commentId || `${S}-${e.t}`; // stable id for dedupe
Â  Â  Â  Â  const tms = e.t;

Â  Â  Â  Â  const alreadyCounted = countedComments.has(cid);

Â  Â  Â  Â  DYNAMIC_ALLOW.add(S);

Â  Â  Â  Â  if (!alreadyCounted) {
Â  Â  Â  Â  Â  mentionQueue.push({ sym: S, t: tms, commentId: cid });
Â  Â  Â  Â  Â  counts.set(S, (counts.get(S) || 0) + 1);
Â  Â  Â  Â  Â  countedComments.add(cid);
Â  Â  Â  Â  }

Â  Â  Â  Â  const providedText = (e.body || e.snippet || "").trim();
Â  Â  Â  Â  const fallbackText = providedText || "(preloaded mention; full body not available yet)";
Â  Â  Â  Â  const meta = {
Â  Â  Â  Â  Â  id: cid,
Â  Â  Â  Â  Â  author: e.author || "u/unknown",
Â  Â  Â  Â  Â  score: e.score ?? 0,
Â  Â  Â  Â  Â  created_utc: Math.floor(tms / 1000),
Â  Â  Â  Â  Â  body: fallbackText,
Â  Â  Â  Â  Â  body_html: "",
Â  Â  Â  Â  Â  permalink: e.permalink || "#",
Â  Â  Â  Â  Â  post: { title: e.postTitle || "", permalink: e.postPermalink || e.permalink || "#" },
Â  Â  Â  Â  Â  postTitle: e.postTitle || ""
Â  Â  Â  Â  };
Â  Â  Â  Â  indexCommentMentionsForSyms(meta, [S]);
Â  Â  Â  }

Â  Â  Â  pruneAndRenderTop();
Â  Â  }

Â  Â  function pruneAndRenderTop(){
Â  Â  Â  const list = document.getElementById("top-tickers");
Â  Â  Â  const resetBtn = document.getElementById("reset-hidden");
Â  Â  Â  const cutoff = Date.now() - WINDOW_MS;
Â  Â  Â  while (mentionQueue.length && mentionQueue[0].t < cutoff){
Â  Â  Â  Â  const old = mentionQueue.shift();
Â  Â  Â  Â  const cur = (counts.get(old.sym) || 0) - 1;
Â  Â  Â  Â  if (cur <= 0) counts.delete(old.sym); else counts.set(old.sym, cur);
Â  Â  Â  }
Â  Â  Â  list.innerHTML = "";
Â  Â  Â  const top = Array.from(counts.entries()).filter(([sym]) => !hiddenTickers.has(sym)).sort((a,b)=>b[1]-a[1]).slice(0, TOP_TICKERS_N);
Â  Â  Â  if (!top.length) {
Â  Â  Â  Â  const li = document.createElement("li"); li.className = "text-zinc-500"; li.textContent = "listeningâ€¦"; list.appendChild(li);
Â  Â  Â  } else {
Â  Â  Â  Â  top.forEach(([sym, cnt]) => {
Â  Â  Â  Â  Â  const li = document.createElement("li");
Â  Â  Â  Â  Â  li.className = "flex items-center justify-between gap-2";
Â  Â  Â  Â  Â  li.innerHTML = `<span class="truncate"><span class="ticker-label">${sym}</span> <span class="text-zinc-400">â€” ${cnt}</span></span><div class="flex items-center gap-2 flex-shrink-0"><button class="see-btn" data-see="${sym}" type="button">See comments</button><button class="hide-btn" data-hide="${sym}" type="button">hide</button></div>`;
Â  Â  Â  Â  Â  list.appendChild(li);
Â  Â  Â  Â  });
Â  Â  Â  Â  list.classList.add("flash"); setTimeout(()=> list.classList.remove("flash"), 420);
Â  Â  Â  }
Â  Â  Â  resetBtn.classList.toggle("hidden", hiddenTickers.size === 0);
Â  Â  }
Â  Â  // modal
Â  Â  const modalEl = document.getElementById("commentsModal");
Â  Â  const modalTitle = document.getElementById("modalTitle");
Â  Â  const modalSubtitle = document.getElementById("modalSubtitle");
Â  Â  const modalList = document.getElementById("modalList");
Â  Â  let openModalSym = null;
Â  Â  const inflightByTicker = new Set();
Â  Â  function getRecentComments(sym){
Â  Â  Â  const arr = commentsByTicker.get(sym) || [];
Â  Â  Â  const cutoff = Date.now() - WINDOW_MS;
Â  Â  Â  const fresh = arr.filter(x => x.t >= cutoff);
Â  Â  Â  if (fresh.length !== arr.length) commentsByTicker.set(sym, fresh);
Â  Â  Â  return fresh;
Â  Â  }
Â  Â  async function backfillTicker(sym){
Â  Â  Â  if (inflightByTicker.has(sym)) return; inflightByTicker.add(sym);
Â  Â  Â  try{
Â  Â  Â  Â  const data = await fetchJson(`${API_BASE}/by_ticker?sym=${encodeURIComponent(sym)}&minutes=60&ts=${Date.now()}`, { timeoutMs: 6000, retries: 2 });
Â  Â  Â  Â  const list = Array.isArray(data) ? data : (data?.items || []);
Â  Â  Â  Â  for (const item of list){
Â  Â  Â  Â  Â  const c = item.comment || item;
Â  Â  Â  Â  Â  const p = item.post || { title: item.postTitle, permalink: item.postPermalink || item.permalink };
Â  Â  Â  Â  Â  indexCommentMentionsForSyms({ ...c, post: p }, [sym]);
Â  Â  Â  Â  }
Â  Â  Â  } catch {} finally {
Â  Â  Â  Â  inflightByTicker.delete(sym);
Â  Â  Â  Â  if (openModalSym === sym) renderModal(sym);
Â  Â  Â  }
Â  Â  }
Â  Â  function openModal(sym){ openModalSym = sym; renderModal(sym); if (getRecentComments(sym).length === 0) backfillTicker(sym); modalEl.classList.remove("hidden"); document.body.style.overflow = "hidden"; }
Â  Â  function closeModal(){ openModalSym = null; modalEl.classList.add("hidden"); document.body.style.overflow = ""; modalList.innerHTML = ""; }
Â  Â  function renderModal(sym){
Â  Â  Â  const items = getRecentComments(sym);
Â  Â  Â  modalTitle.innerHTML = `<span class="ticker-label">${sym}</span> comments`;
Â  Â  Â  modalSubtitle.textContent = `${items.length} mention${items.length===1?"":"s"} in the last hour`;
Â  Â  Â  modalList.innerHTML = "";
Â  Â  Â  if (!items.length){
Â  Â  Â  Â  const empty = document.createElement("div");
Â  Â  Â  Â  empty.className = "text-sm text-zinc-400";
Â  Â  Â  Â  empty.textContent = "Fetching comments for this tickerâ€¦";
Â  Â  Â  Â  modalList.appendChild(empty);
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  for (const c of items){
Â  Â  Â  Â  const card = document.createElement("article");
Â  Â  Â  Â  card.className = "frame p-3 md:p-4";
Â  Â  Â  Â  const when = timeAgo(c.t);
Â  Â  Â  Â  const plain = (c.body_html ? stripHtmlToText(c.body_html) : (c.body || "")).trim();
Â  Â  Â  Â  const hi = highlightTickers(escapeHtml(plain || "(preloaded mention; full body not available yet)"));
Â  Â  Â  Â  card.innerHTML = `
Â  Â  Â  Â  Â  <header class="flex items-center justify-between text-xs text-zinc-300 mb-2">
Â  Â  Â  Â  Â  Â  <div class="flex items-center gap-2 flex-wrap">
Â  Â  Â  Â  Â  Â  Â  <span class="chip">u:${escapeHtml(formatUser(c.author))}</span>
Â  Â  Â  Â  Â  Â  Â  <span class="chip">score ${c.score ?? 0}</span>
Â  Â  Â  Â  Â  Â  Â  <span class="chip">${when}</span>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <a href="${c.permalink}" target="_blank" rel="noopener" class="underline decoration-dotted">Open on Reddit â†—</a>
Â  Â  Â  Â  Â  </header>
Â  Â  Â  Â  Â  ${c.postTitle ? `<h4 class="font-semibold text-sm mb-2">${escapeHtml(c.postTitle)}</h4>` : ``}
Â  Â  Â  Â  Â  <div class="text-sm body-html"><p>${hi}</p></div>
Â  Â  Â  Â  `;
Â  Â  Â  Â  modalList.appendChild(card);
Â  Â  Â  }
Â  Â  }

Â  Â  document.addEventListener("click", (e) => {
Â  Â  Â  try {
Â  Â  Â  Â  const hideBtn = e.target.closest(".hide-btn");
Â  Â  Â  Â  if (hideBtn && hideBtn.hasAttribute("data-hide")) { hiddenTickers.add(hideBtn.getAttribute("data-hide")); saveHidden(); pruneAndRenderTop(); return; }
Â  Â  Â  Â  if (e.target && e.target.id === "reset-hidden") { hiddenTickers.clear(); saveHidden(); pruneAndRenderTop(); return; }
Â  Â  Â  Â  const seeBtn = e.target.closest(".see-btn, .ticker-token");
Â  Â  Â  Â  if (seeBtn && seeBtn.hasAttribute("data-see")) { openModal(seeBtn.getAttribute("data-see")); return; }
Â  Â  Â  Â  if (e.target && (e.target.id === "modalClose" || e.target.hasAttribute("data-close-modal"))) { closeModal(); return; }
Â  Â  Â  } catch {}
Â  Â  });

Â  Â  // ===== live 5s poller (strict forward) =====
Â  Â  let _lastShownMs = 0;
Â  Â  let paused = false;
Â  Â  let tickTimer = null;
Â  Â  let healthTimer = null;
Â  Â  let consecutiveFailures = 0;
Â  Â  let _lastRendered = null;

Â  Â  function setPaused(p){
Â  Â  Â  paused = p;
Â  Â  Â  pauseBtn.textContent = paused ? "Unpause" : "Pause";
Â  Â  Â  liveDot.classList.toggle("paused", paused);
Â  Â  Â  statusEl.textContent = paused ? "paused" : "live";
Â  Â  Â  if (paused) stopTimers(); else startTimers();
Â  Â  }
Â  Â  pauseBtn.addEventListener("click", () => setPaused(!paused));

Â  Â  function startTimers(){
Â  Â  Â  stopTimers();
Â  Â  Â  tickTimer = setInterval(pollOnce, 5000);
Â  Â  Â  healthTimer = setInterval(healthCheck, 15000);
Â  Â  Â  pollOnce();
Â  Â  Â  healthCheck();
Â  Â  }
Â  Â  function stopTimers(){
Â  Â  Â  if (tickTimer) clearInterval(tickTimer);
Â  Â  Â  if (healthTimer) clearInterval(healthTimer);
Â  Â  Â  tickTimer = null; healthTimer = null;
Â  Â  }

Â  Â  async function healthCheck(){
Â  Â  Â  const h = await fetchJson(API_BASE + "/health", { timeoutMs: 2500, retries: 0 });
Â  Â  Â  if (!h?.ok) {
Â  Â  Â  Â  statusEl.textContent = "reconnectingâ€¦";
Â  Â  Â  } else if (!paused) {
Â  Â  Â  Â  statusEl.textContent = "live";
Â  Â  Â  }
Â  Â  }

Â  Â  async function pollOnce(){
Â  Â  Â  if (paused) return;

Â  Â  Â  const res = await fetchJson(`${API_BASE}/recent_comments?minutes=3&ts=${Date.now()}`, { timeoutMs: 2200, retries: 0 });
Â  Â  Â  if (!res) {
Â  Â  Â  Â  consecutiveFailures++;
Â  Â  Â  Â  statusEl.textContent = "reconnectingâ€¦";
Â  Â  Â  Â  if (consecutiveFailures >= 3) showErr("Network hiccup contacting API. Retryingâ€¦");
Â  Â  Â  Â  if (_lastRendered) renderMain(_lastRendered);
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  clearErr();
Â  Â  Â  consecutiveFailures = 0;

Â  Â  Â  const list = Array.isArray(res) ? res : (res.items || []);
Â  Â  Â  if (!Array.isArray(list) || list.length === 0) {
Â  Â  Â  Â  if (_lastRendered) renderMain(_lastRendered);
Â  Â  Â  Â  statusEl.textContent="live";
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  const chosen = list[0];
Â  Â  Â  const c = chosen.comment || chosen;
Â  Â  Â  const ts = Math.min(((c?.created_utc||0)*1000) || Date.now(), Date.now());

Â  Â  Â  if (ts > _lastShownMs) {
Â  Â  Â  Â  const post = chosen.post || { title: chosen.postTitle, permalink: chosen.postPermalink || chosen.permalink };
Â  Â  Â  Â  const parents = chosen.parents || [];
Â  Â  Â  Â  const payload = { comment: c, parents, post };
Â  Â  Â  Â  renderMain(payload);
Â  Â  Â  Â  _lastRendered = payload;
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  if (_lastRendered) {
Â  Â  Â  Â  renderMain(_lastRendered);
Â  Â  Â  } else {
Â  Â  Â  Â  const post = chosen.post || { title: chosen.postTitle, permalink: chosen.postPermalink || chosen.permalink };
Â  Â  Â  Â  const parents = chosen.parents || [];
Â  Â  Â  Â  const payload = { comment: c, parents, post };
Â  Â  Â  Â  renderMain(payload);
Â  Â  Â  Â  _lastRendered = payload;
Â  Â  Â  }
Â  Â  }

Â  Â  function renderMain({ comment, parents, post }){
Â  Â  Â  const node = tmpl.content.firstElementChild.cloneNode(true);
Â  Â  Â  q(node,"[data-author]").textContent = formatUser(comment.author);
Â  Â  Â  q(node,"[data-score]").textContent = comment.score ?? 0;
Â  Â  Â  q(node,"[data-time]").textContentÂ  = timeAgo(comment.created_utc*1000);
Â  Â  Â  q(node,"[data-post-link]").textContent = post?.title || "(post)";
Â  Â  Â  q(node,"[data-post-link]").href = post?.permalink || "#";
Â  Â  Â  q(node,"[data-comment-link]").href = comment.permalink;

Â  Â  Â  const thread = q(node, "[data-thread]");
Â  Â  Â  (parents||[]).forEach(p => {
Â  Â  Â  Â  // FIX APPLIED: Pass raw body_html (or body) to blockHtml for stripping/highlighting
Â  Â  Â  Â  thread.appendChild(blockHtml(p, p.body_html || p.body, false));
Â  Â  Â  });
Â  Â  Â  // FIX APPLIED: Pass raw body_html (or body) to blockHtml for stripping/highlighting
Â  Â  Â  thread.appendChild(blockHtml(comment, comment.body_html || comment.body, true));

Â  Â  Â  const ts = Math.min((comment.created_utc||0)*1000, Date.now());
Â  Â  Â  if (ts > _lastShownMs) _lastShownMs = ts;

Â  Â  Â  const commentId = comment.id || comment.name || comment.permalink;
Â  Â  Â  const plain = stripHtmlToText(comment.body_html||"") || comment.body || "";
Â  Â  Â  addCommentMentions(commentId, plain);
Â  Â  Â  indexCommentMentions({...comment, post}, plain);

Â  Â  Â  mainPane.innerHTML = "";
Â  Â  Â  mainPane.appendChild(node);
Â  Â  Â  statusEl.textContent = "live";
Â  Â  }
Â  Â  function q(node, sel){ return node.querySelector(sel); }
Â  Â  
Â  Â  // FIX APPLIED: blockHtml now strips HTML before highlighting/escaping
Â  Â  function blockHtml(meta, rawContent, isCurrent=false){
Â  Â  Â  // 1. Strip the HTML tags from the raw content (e.g., <p>, <div>)
Â  Â  Â  const plainText = stripHtmlToText(rawContent || "");
Â  Â  Â  // 2. Escape the plain text for safety, then apply ticker highlighting
Â  Â  Â  const inner = highlightTickers(escapeHtml(plainText));
Â  Â  Â  const wrap = document.createElement("div");
Â  Â  Â  wrap.className = isCurrent ? "current-block gain-border" : "parent-block";
Â  Â  Â  if (isCurrent) wrap.classList.add("flash");
Â  Â  Â  // Wrap the final clean text in a paragraph tag for layout consistency
Â  Â  Â  wrap.innerHTML = `<div class="text-xs text-zinc-300 mb-2">u:${escapeHtml(formatUser(meta.author))} â€¢ ${timeAgo(meta.created_utc * 1000)} â€¢ score ${meta.score ?? 0}</div><div class="text-sm body-html"><p>${inner}</p></div>`;
Â  Â  Â  return wrap;
Â  Â  }

Â  Â  // ===== preload top tickers (1h) on boot, with retries =====
Â  Â  async function preheatTopTickers(minutes=60){
Â  Â  Â  for (let attempt = 1; attempt <= 6; attempt++) {
Â  Â  Â  Â  const [r1, r2] = await Promise.allSettled([
Â  Â  Â  Â  Â  fetchJson(`${API_BASE}/recent_comments?minutes=${minutes}&ts=${Date.now()}`, { timeoutMs: 9000, retries: 1 }),
Â  Â  Â  Â  Â  fetchJson(`${API_BASE}/seed?minutes=${minutes}&ts=${Date.now()}`, { timeoutMs: 9000, retries: 1 }),
Â  Â  Â  Â  ]);

Â  Â  Â  Â  let any = false;
Â  Â  Â  Â  if (r1.status === "fulfilled" && r1.value) {
Â  Â  Â  Â  Â  const arr = Array.isArray(r1.value) ? r1.value : (r1.value.items || []);
Â  Â  Â  Â  Â  for (const it of arr) {
Â  Â  Â  Â  Â  Â  const c = it.comment || it;
Â  Â  Â  Â  Â  Â  const p = it.post || { title: it.postTitle, permalink: it.postPermalink || it.permalink };
Â  Â  Â  Â  Â  Â  const plain = c.body || (c.body_html ? stripHtmlToText(c.body_html) : "");
Â  Â  Â  Â  Â  Â  indexCommentMentions({ ...c, post: p }, plain);
Â  Â  Â  Â  Â  Â  addCommentMentions(c.id || c.name || c.permalink || Math.random().toString(36).slice(2), plain);
Â  Â  Â  Â  Â  Â  any = true;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (r2.status === "fulfilled" && r2.value) {
Â  Â  Â  Â  Â  const entries = Array.isArray(r2.value?.entries) ? r2.value.entries : (Array.isArray(r2.value) ? r2.value : []);
Â  Â  Â  Â  Â  if (entries.length) { addSeedEntries(entries); any = true; }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (any) { pruneAndRenderTop(); return; }
Â  Â  Â  Â  await new Promise(res => setTimeout(res, Math.min(2000 * attempt, 12000)));
Â  Â  Â  }
Â  Â  Â  showErr("Top tickers preload had no data yet. It will fill as new comments arrive.");
Â  Â  }

Â  Â  // ===== posts rail =====
Â  Â  let _lastPosts = [];

Â  Â  async function loadPosts(){
Â  Â  Â  const p = await fetchJson(API_BASE + "/posts", { timeoutMs: 4500, retries: 1 });
Â  Â  Â  const list = (p && Array.isArray(p.posts)) ? p.posts : [];

Â  Â  Â  if (!list.length) return;

Â  Â  Â  if (_lastPosts.length && list[0]?.id === _lastPosts[0]?.id) return;

Â  Â  Â  postsEl.innerHTML = "";
Â  Â  Â  for (const post of list) {
Â  Â  Â  Â  const node = postTmpl.content.firstElementChild.cloneNode(true);
Â  Â  Â  Â  const q = (n,s) => n.querySelector(s);
Â  Â  Â  Â  q(node,"[data-post-link]").textContent = post.title;
Â  Â  Â  Â  q(node,"[data-post-link]").href = post.permalink;
Â  Â  Â  Â  q(node,"[data-author]").textContent = post.author;
Â  Â  Â  Â  q(node,"[data-time]").textContent = timeAgo(post.created_utc * 1000);
Â  Â  Â  Â  q(node,"[data-score]").textContent = post.score ?? 0;
Â  Â  Â  Â  q(node,"[data-comments]").textContent = post.comments ?? 0;
Â  Â  Â  Â  postsEl.appendChild(node);
Â  Â  Â  }

Â  Â  Â  _lastPosts = list;
Â  Â  }

Â  Â  // ===== boot =====
Â  Â  (async function boot(){
Â  Â  Â  const h = await fetchJson(API_BASE + "/health", { timeoutMs: 2500, retries: 0 });
Â  Â  Â  if (!h?.ok) showErr("Backend health check failed. If this persists, your Worker may not be deployed.");

Â  Â  Â  startTimers();
Â  Â  Â  preheatTopTickers();
Â  Â  Â  loadPosts();
Â  Â  Â  setInterval(loadPosts, 60000);
Â  Â  })();
Â  </script>
</body>

</html>
